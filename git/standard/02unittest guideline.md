Unittest & CodeReview 原则
--------

# [Unittest 官方手册](https://phpunit.de/manual/4.8/zh_cn/database.html)
# [Unittest 断言手册](https://phpunit.de/manual/4.8/zh_cn/appendixes.assertions.html)

## 小提示

1. 经常进行Code Review
1. Code Review不要太正式，而且要短
1. 尽可能的让不同的人Reivew你的代码
1. 保持积极的正面的态度
1. 学会享受Code Reivew

## 原则

> 单元测试只是开始，不是结束

* 一个断言只验证一件事
* 有错误，`立刻停下`后续流程，解决问题后才能继续流程;
* 如果有单元测试模块，`必须`保证修改提交代码，有`单元测试覆盖`才能上线;
* `集成流程`中，QA 发现的BUG，开发者`必须`添加对应的测试用例;
* `hotfix` 可以`稍后`再添加对应的单元测试，但同样要遵守后续原则;
* 单元测试统一使用 `mia_test` 测试库;
* 没有单元测试，`不能`上线;
* 单元测试`全部`通过，才能提交MergeRequest、上线;
 * 包括但不限以下流程：`feature`, `integration`, `bugfix`, `release`, `hotfix`;

## 作者
* `谁`实现`feature`，`谁`实现单元测试;
* `谁`修复`bug`，`谁`添加对应的单元测试;

## 范围
* 业务层、数据层`添加`必要的单元测试
 * 包括但不限于以下业务：核心读取、插入、修改、更新数据
 * 非核心读取可以不覆盖
* 控制器、视图层`暂不`考虑单元测试

## 执行
 * 测试新添加的单元测试【`必做`】

    > ./sync test MyTest

 * 测试全部单元测试【`必做`】

    > ./sync test

## 查看输出信息排错

* 如果`没有输出`，或者有`任何错误`，请登陆服务器，查看以下文件日志

     >  tail -f /opt/logs/php_errors.log
 
* 如果有`大量异常错误输出`
 *  可以尝试，手动删除工作区下`application/config/database.php` 文件，或者 `./sync clean`自动清理；
 * 重新运行./sync ，查看测试结果
* [单元测试突然中断怎么办？？？](how-to-do-when-unittest-break-off)

# 好处

* Code reviews 中，可以通过大家的建议增进代码的质量。
* Code reviews  是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。
* Code reviews 也鼓励程序员们相互学习对方的长处和优点。
* Code reviews 也可以被用来确认自己的设计和实现是一个清楚和简单的。

# 正确认知 
* Code reviews `不应该`承担发现代码错误的职责。

> Code Review主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证的（其中主要是单元测试，因为那是最接近Bug，也是Bug没有扩散的地方）

* Code reviews `不应该`成为保证代码风格和编码标准的手段。

> 编码风格和代码规范都属于死的东西，每个程序员在把自己的代码提交团队Review的时候，代码就应该是符合规范的，这是默认值，属于每个人自己的事情，不应该交由团队来完成，否则只会浪费大家本来就不够的时间。我个人认为“meeting”是奢侈的，因为那需要大家在同一时刻都挤出时间，所以应该用在最需要的地方。代码规范比起程序的逻辑和对需求设计的实现来说，太不值得让大家都来了。


# 错误认知

* 我实现了这个功能，以后再补上单元测试

    > 先上飞机，后买票是不可能的

    > `以后`就是没有`以后`

* 我测试了自己的单元测试，就不需要运行其他人的单元测试了

    > 团队的产品，不是只关心自己的功能

    > 对此问题没有意识：其他人的功能和单元测试，是否会影响自己的功能和单元测试

    > 自己的功能和单元测试，一定会破坏其他人 ---- 【墨菲定律】

* 单元测试有问题，先上线再说吧

    > 测试不通过，就是系统有问题，系统有问题，就是不能上线

    > “上线的代码有问题，用户遇到问题再解决，等CEO发现了再解决” 这是不可能的

    > 上线以后的产品，会影响公司所有业务，业务所有用户，客户所有行为

    > 线下解决1小时，线上解决10小时


# 单元测试的四个阶段

> Gerard Meszaros 在他的书《xUnit 测试模式》中列出了单元测试的四个阶段：
> 1.    建立基境(fixture)
> 2.    执行被测系统
> 3.    验证结果
> 4.    拆除基境(fixture)

> 什么是基境(fixture)？

> 基境(fixture)是对开始执行某个测试时应用程序和数据库所处初始状态的描述。

# PHPUnit 编写测试的基本惯例与步骤：

1. 针对类 `XXXClass` 的测试写在类 `XXXClassTest` 中。
1. `ClassTest`（通常）继承自 `PHPUnit_Framework_TestCase`，本项目采用继承自`GameUnit`。
1. 测试都是命名为 `test*` 的公用方法。
1. 也可以在方法的文档注释块(docblock)中使用 `@test` 标注将其标记为测试方法。
1. 在测试方法内，类似于 `assertEquals()`（参见 [附录 A](https://phpunit.de/manual/4.8/zh_cn/appendixes.assertions.html)）这样的断言方法用来对实际值与预期值的匹配做出断言。


# 一些单元测试的Guideline

1.  [Lior Friedman](https://groups.yahoo.com/neo/groups/testdrivendevelopment/conversations/topics/31412) “第0条 – 测试应该只测试单元其外部的行为，而不是内部的结构”。或者说，只测试对一个单元的期望，而不是这个单元的构成。

1. [Jimmy Bogard](http://www.lostechies.com/blogs/jimmy_bogard/archive/2008/12/18/getting-value-out-of-your-unit-tests.aspx) 测试名应该从用户的角度描述是什么和为什么

    > 这样一来，程序员可以从名字就可以知道用户需要什么样的软件行为。

1. 测试也是代码，同样也需要我们更多的爱

    > 真实运行在生产环境下的代码不仅仅只是我们需要去关心和花心思的代码。对于单元测试中的代码同样也需要易读易维护，以及可重用的特性。***“我非常痛恨那些又长又复杂的测试代码，如果一个测试需要30行的单元测试代码，请把其放在一个方法中。一个长的测试步骤只会激怒程序员。如果你在正式的代码中都没有这么长的代码，那么为什么我们需要在测试代码中容忍这样的情形呢？”***

1. 不要只用一种固定的模式或组织风格
    >  有些时候，对于一些特殊的测试案例，标准的类设计模式，或一个固有的测试装置可能并不能有效的工作。

## [Ravichandran Jv](https://groups.google.com/d/msg/nunit-discuss/bnDpZGdle60/AhVzR1bXyVYJ) 也加上了他的条例：

1. 一个测试一个断言（如果可能）。 
1. 如果在测试中有“if else” 的语句，请把if和else两个分支拆分成两个测试案例。 
1. 如果一个测试案例中也有if else 分枝，那么这个测试案例也需要被重构。
1. 测试案例的命名代表了这种测试的类型。例如：TestMakeReservation() 和TestMakeNoReservation()是不一样的类型。